# O modelo é bom
modelo <- randomForest(resultado ~ gov + minoria + pt + pmdb
+ psdb + psd + TIPO + prp + pr + pps,
data=votos, ntree=500)
modelo
varImpPlot(modelo)
votos$previsor <- predict(modelo,votos)
plot(votos$previsor, votos$resultado)
votos$resultado2 <- ifelse(votos$resultado >= (votos$contagem)/2, 1, 0)
votos$resultado2[votos$TIPO=="PEC"] <- ifelse(votos$resultado[votos$TIPO=="PEC"] >= 308, 1, 0)
votos$previsor2 <- ifelse(votos$previsor >= (votos$contagem)/2, 1, 0)
votos$previsor2[votos$TIPO=="PEC"] <- ifelse(votos$previsor[votos$TIPO=="PEC"] >= 308, 1, 0)
table(votos$resultado2, votos$previsor2)
41 + 75
116/(8 + 116)
setwd('/var/www//html/twitter-protesto/')
library(sqldf)
?dbConnect
library(RMySQL)
?dbConnect
install.packages('RMongo')
library(RMongo)
?mongoDbConnect
db <- mongoDbConnect('twitter', host='192.168.0.10')
db
print(dbShowCollections(db))
?dbGetQuery
print(dbShowCollections(db))
result = dbGetQuery(db, "dilma_16_ago", "{}", 0, 10)
result
str(result)
result = dbGetQuery(db, "dilma_16_ago", "{}", 0, 300)
result = dbGetQuery(db, "dilma_16_ago", "{}", 0, 600)
result = select(result, text)
result = dbGetQuery(db, "dilma_16_ago", "{}", 0, 1000)
result = select(result, text)
write.csv(result, 'textos_twitter.csv', row.names=FALSE)
result = dbGetQuery(db, "dilma_16_ago", "{}", 0, 1000)
result[,16]
result[16,]
result[15,]
result[15,]$text
hist(votos$contagem)
media_contagem <- mean(votos$contagem)
media_contagem
votos$resultado3 <- ifelse(votos$resultado >= (media_contagem)/2, 1, 0)
votos$resultado3[votos$TIPO=="PEC"] <- ifelse(votos$resultado[votos$TIPO=="PEC"] >= 308, 1, 0)
votos$previsor3 <- ifelse(votos$previsor >= (media_contagem)/2, 1, 0)
votos$previsor3[votos$TIPO=="PEC"] <- ifelse(votos$previsor[votos$TIPO=="PEC"] >= 308, 1, 0)
table(votos$resultado3, votos$previsor3)
table(votos$resultado2, votos$previsor2)
3 + 6 + 71 + 44
table(votos$resultado2, votos$previsor3)
votos$previsor3 <- ifelse(votos$previsor >= (media_contagem+50)/2, 1, 0)
votos$previsor3[votos$TIPO=="PEC"] <- ifelse(votos$previsor[votos$TIPO=="PEC"] >= 308, 1, 0)
table(votos$resultado2, votos$previsor3)
votos$previsor3 <- ifelse(votos$previsor >= (media_contagem+20)/2, 1, 0)
votos$previsor3[votos$TIPO=="PEC"] <- ifelse(votos$previsor[votos$TIPO=="PEC"] >= 308, 1, 0)
table(votos$resultado2, votos$previsor3)
votos$previsor3 <- ifelse(votos$previsor >= (media_contagem-50)/2, 1, 0)
votos$previsor3[votos$TIPO=="PEC"] <- ifelse(votos$previsor[votos$TIPO=="PEC"] >= 308, 1, 0)
table(votos$resultado2, votos$previsor3)
(3 + 9)/124
library(tidyr)
library(dplyr)
# Burga, muda essa pasta
setwd('/var/www/html/vai-passar/previsor/planilhas/')
orientacoes <- read.csv('orientacoes.csv', stringsAsFactors=FALSE, sep=';', header=FALSE)
# Abre o banco
# orientacoes$V5[orientacoes$V5=="Não"] <- 0
# orientacoes$V5[orientacoes$V5=="Sim"] <- 1
# orientacoes$V5[orientacoes$V5=="Liberado"] <- NA
# orientacoes$V5[orientacoes$V5=="Obstrução"] <- NA
# Processa a variável V5
orientacoes$V4[orientacoes$V4=="PmdbPpPtbDem..."] <- "Pmdb|Pp|Ptb|Dem"
orientacoes$V4[orientacoes$V4=="PmdbPpPtbDemPscPhsPen"] <- "Pmdb|Pp|Ptb|Dem|Psc|Phs|Pen"
orientacoes$V4[orientacoes$V4=="PmdbPpPtbDemSdPscPhsPen"] <- "Pmdb|Pp|Ptb|Dem|Sd|Psc|Phs|Pen"
orientacoes$V4[orientacoes$V4=="PmdbPpPtbPscPhsPen"] <- "Pmdb|Pp|Ptb|Psc|Phs|Pen"
orientacoes$V4[orientacoes$V4=="PrbPtnPmnPrpPsdcPrtb"] <- "Prb|Ptn|Pmn|Prp|Psdc|Prtb"
orientacoes$V4[orientacoes$V4=="PrbPtnPmnPrpPsdcPrtbPtcPslPtdoB"] <- "Prb|Ptn|Pmn|Prp|Psdc|Prtb|Ptc|Psl|PtdoB"
orientacoes$V4[orientacoes$V4=="PsdbPsbPpsPv"] <- "Psdb|Psb|Pps|Pv"
orientacoes$V4[orientacoes$V4=="PtPsdPrPdtProsPc"] <- "Psdb|Psb|Pps|Pv"
orientacoes$V4[orientacoes$V4=="Repr.PSL"] <- "PSL"
orientacoes$V4[orientacoes$V4=="Repr.PTC"] <- "PTC"
orientacoes$V4[orientacoes$V4=="Repr.PTdoB"] <- "PTdoB"
orientacoes$V4[orientacoes$V4=="Solidaried"] <- "SD"
orientacoes$V4[orientacoes$V4=="GOV."] <- "Gov"
orientacoes$V4[orientacoes$V4=="Repr.PSOL"] <- "psol"
orientacoes$V4[orientacoes$V4=="PtPsdPrPdtProsPcdob"] <- "Pt|Psd|Pr|Pdt|Pros|Pcdob"
orientacoes$V4[orientacoes$V4=="PsdbPsbPps"] <- "Psdb|Psb|Pps"
# Altera as entradas pra facilitar trabalho
# Estamos separando partidos com '|', para poder separa-los em colunas
# posteriormente
orientacoes$V4 <- tolower(orientacoes$V4)
# transforma partidos tudo para letras minusculas
orientacoes <- orientacoes %>%
transform(V4 = strsplit(V4, "\\|")) %>%
unnest(V4)
# Separa as variaveis
colnames(orientacoes) <- c("ID_VOTACAO", "DATA", "HORA", "PARTIDO", "ORIENTACAO")
# Altera nomes das colunas de "V4" para nomes pertinentes
orientacoes <- orientacoes[!duplicated(orientacoes),]
# Remove valores duplicados
# Obter apenas a orientacao do governo. Para isso, copiamos o df:
orientacoes <- mutate(orientacoes, ORIENTACAO=ifelse(ORIENTACAO=="Obstrução", "Não", ORIENTACAO))
orientacoes <- spread(orientacoes, PARTIDO, ORIENTACAO)
#  orientacoes <- select(orientacoes, ID_VOTACAO, pt, pmdb, psd, pcdob, pdt, prb, pr , pros)
votos <- read.csv("votos.csv", , stringsAsFactors=FALSE, sep=';')
proposicoes <- read.csv("proposicoes.csv", stringsAsFactors=FALSE, sep=';')
conta_sim <- function(x) {
n_sim <- try(table(x)[["SIM"]], TRUE)
return(n_sim)
}
votos <- votos %>%
filter((VOTO=="SIM" | VOTO=="NAO")) %>%
mutate(votos_sim=ifelse(VOTO=="SIM", 1, 0)) %>%
group_by(ID_VOTACAO) %>%
summarise(contagem=n(), votos_sim=sum(votos_sim))
votos <- inner_join(votos, proposicoes)
votos$APROV_numero <- ifelse(votos$votos_sim >= (votos$contagem)/2, 1, 0)
votos$APROV_numero[votos$TIPO=="PEC"] <- ifelse(votos$votos_sim[votos$TIPO=="PEC"] >= 308, 1, 0)
library(randomForest)
votos <- inner_join(votos,orientacoes, by="ID_VOTACAO")
votos <- select(votos, ID_VOTACAO, dem, gov, minoria, sd,starts_with("p"), resultado=APROV_numero)
votos$resultado <- ifelse(votos$resultado==1, "Sim", "Não")
votos$resultado <- as.factor(votos$resultado)
nome_colunas <- colnames(votos)[2:length(colnames(votos))]
for (i in nome_colunas) {
print(i)
print(sum(is.na(votos[[i]])))
}
# votosn <- inner_join(votos, proposicoes, by="ID_VOTACAO")
# write.csv(votosn, file="orietacoes_e_votacoes.csv", row.names=FALSE)
#Excluindo PSOL, pois possui muitas NAs
# Também vamos excluir ptc, ptdob, pros e sd
votos <- select(votos, -ptc, -ptdob, -pros, -sd, -psl, -pp, -prb, -psb, -dem)
### Rodando
for (i in colnames(votos)) {
votos[[i]] <- as.factor(votos[[i]])
}
train_lines <- sample(nrow(votos)*.70)
train <- votos[train_lines,]
test <- votos[-train_lines,]
modelo <- randomForest(resultado ~ gov + minoria + pt + pmdb
+ psdb + psd,
data=train, ntree=500)
modelo
modelo <- randomForest(resultado ~ gov + minoria + pt + pmdb
+ psdb + psd + TIPO + prp + pr + pps,
data=votos, ntree=500)
# Este banco indica quais orientacoes de votacoes para cada partido e para o governo
library(tidyr)
library(dplyr)
# Burga, muda essa pasta
setwd('/var/www/html/vai-passar/previsor/planilhas/')
orientacoes <- read.csv('orientacoes.csv', stringsAsFactors=FALSE, sep=';', header=FALSE)
# Abre o banco
# orientacoes$V5[orientacoes$V5=="Não"] <- 0
# orientacoes$V5[orientacoes$V5=="Sim"] <- 1
# orientacoes$V5[orientacoes$V5=="Liberado"] <- NA
# orientacoes$V5[orientacoes$V5=="Obstrução"] <- NA
# Processa a variável V5
orientacoes$V4[orientacoes$V4=="PmdbPpPtbDem..."] <- "Pmdb|Pp|Ptb|Dem"
orientacoes$V4[orientacoes$V4=="PmdbPpPtbDemPscPhsPen"] <- "Pmdb|Pp|Ptb|Dem|Psc|Phs|Pen"
orientacoes$V4[orientacoes$V4=="PmdbPpPtbDemSdPscPhsPen"] <- "Pmdb|Pp|Ptb|Dem|Sd|Psc|Phs|Pen"
orientacoes$V4[orientacoes$V4=="PmdbPpPtbPscPhsPen"] <- "Pmdb|Pp|Ptb|Psc|Phs|Pen"
orientacoes$V4[orientacoes$V4=="PrbPtnPmnPrpPsdcPrtb"] <- "Prb|Ptn|Pmn|Prp|Psdc|Prtb"
orientacoes$V4[orientacoes$V4=="PrbPtnPmnPrpPsdcPrtbPtcPslPtdoB"] <- "Prb|Ptn|Pmn|Prp|Psdc|Prtb|Ptc|Psl|PtdoB"
orientacoes$V4[orientacoes$V4=="PsdbPsbPpsPv"] <- "Psdb|Psb|Pps|Pv"
orientacoes$V4[orientacoes$V4=="PtPsdPrPdtProsPc"] <- "Psdb|Psb|Pps|Pv"
orientacoes$V4[orientacoes$V4=="Repr.PSL"] <- "PSL"
orientacoes$V4[orientacoes$V4=="Repr.PTC"] <- "PTC"
orientacoes$V4[orientacoes$V4=="Repr.PTdoB"] <- "PTdoB"
orientacoes$V4[orientacoes$V4=="Solidaried"] <- "SD"
orientacoes$V4[orientacoes$V4=="GOV."] <- "Gov"
orientacoes$V4[orientacoes$V4=="Repr.PSOL"] <- "psol"
orientacoes$V4[orientacoes$V4=="PtPsdPrPdtProsPcdob"] <- "Pt|Psd|Pr|Pdt|Pros|Pcdob"
orientacoes$V4[orientacoes$V4=="PsdbPsbPps"] <- "Psdb|Psb|Pps"
# Altera as entradas pra facilitar trabalho
# Estamos separando partidos com '|', para poder separa-los em colunas
# posteriormente
orientacoes$V4 <- tolower(orientacoes$V4)
# transforma partidos tudo para letras minusculas
orientacoes <- orientacoes %>%
transform(V4 = strsplit(V4, "\\|")) %>%
unnest(V4)
# Separa as variaveis
colnames(orientacoes) <- c("ID_VOTACAO", "DATA", "HORA", "PARTIDO", "ORIENTACAO")
# Altera nomes das colunas de "V4" para nomes pertinentes
orientacoes <- orientacoes[!duplicated(orientacoes),]
# Remove valores duplicados
# Obter apenas a orientacao do governo. Para isso, copiamos o df:
orientacoes <- mutate(orientacoes, ORIENTACAO=ifelse(ORIENTACAO=="Obstrução", "Não", ORIENTACAO))
orientacoes <- spread(orientacoes, PARTIDO, ORIENTACAO)
#  orientacoes <- select(orientacoes, ID_VOTACAO, pt, pmdb, psd, pcdob, pdt, prb, pr , pros)
votos <- read.csv("votos.csv", , stringsAsFactors=FALSE, sep=';')
proposicoes <- read.csv("proposicoes.csv", stringsAsFactors=FALSE, sep=';')
conta_sim <- function(x) {
n_sim <- try(table(x)[["SIM"]], TRUE)
return(n_sim)
}
votos <- votos %>%
filter((VOTO=="SIM" | VOTO=="NAO")) %>%
mutate(votos_sim=ifelse(VOTO=="SIM", 1, 0)) %>%
group_by(ID_VOTACAO) %>%
summarise(contagem=n(), votos_sim=sum(votos_sim))
votos <- inner_join(votos, proposicoes)
library(randomForest)
votos <- inner_join(votos,orientacoes, by="ID_VOTACAO")
votos <- select(votos, ID_VOTACAO, contagem, dem, TIPO, gov, minoria, sd,starts_with("p"), resultado=votos_sim)
nome_colunas <- colnames(votos)[2:length(colnames(votos))]
for (i in nome_colunas) {
print(i)
print(sum(is.na(votos[[i]])))
}
# votosn <- inner_join(votos, proposicoes, by="ID_VOTACAO")
# write.csv(votosn, file="orietacoes_e_votacoes.csv", row.names=FALSE)
#Excluindo PSOL, pois possui muitas NAs
# Também vamos excluir ptc, ptdob, pros e sd
votos <- select(votos, -ptc, -ptdob, -pros, -sd, -psl, -pp, -prb, -psb, -dem)
### Rodando
for (i in colnames(votos)) {
if (i != "resultado" & i !="contagem") {
votos[[i]] <- as.factor(votos[[i]])
}
}
# O modelo é bom
modelo <- randomForest(resultado ~ gov + minoria + pt + pmdb
+ psdb + psd + TIPO + prp + pr + pps,
data=votos, ntree=500)
for (i in nome_colunas) {
print(i)
print(sum(is.na(votos[[i]])))
}
# Este banco indica quais orientacoes de votacoes para cada partido e para o governo
library(tidyr)
library(dplyr)
# Burga, muda essa pasta
setwd('/var/www/html/vai-passar/previsor/planilhas/')
orientacoes <- read.csv('orientacoes.csv', stringsAsFactors=FALSE, sep=';', header=FALSE)
# Abre o banco
# orientacoes$V5[orientacoes$V5=="Não"] <- 0
# orientacoes$V5[orientacoes$V5=="Sim"] <- 1
# orientacoes$V5[orientacoes$V5=="Liberado"] <- NA
# orientacoes$V5[orientacoes$V5=="Obstrução"] <- NA
# Processa a variável V5
orientacoes$V4[orientacoes$V4=="PmdbPpPtbDem..."] <- "Pmdb|Pp|Ptb|Dem"
orientacoes$V4[orientacoes$V4=="PmdbPpPtbDemPscPhsPen"] <- "Pmdb|Pp|Ptb|Dem|Psc|Phs|Pen"
orientacoes$V4[orientacoes$V4=="PmdbPpPtbDemSdPscPhsPen"] <- "Pmdb|Pp|Ptb|Dem|Sd|Psc|Phs|Pen"
orientacoes$V4[orientacoes$V4=="PmdbPpPtbPscPhsPen"] <- "Pmdb|Pp|Ptb|Psc|Phs|Pen"
orientacoes$V4[orientacoes$V4=="PrbPtnPmnPrpPsdcPrtb"] <- "Prb|Ptn|Pmn|Prp|Psdc|Prtb"
orientacoes$V4[orientacoes$V4=="PrbPtnPmnPrpPsdcPrtbPtcPslPtdoB"] <- "Prb|Ptn|Pmn|Prp|Psdc|Prtb|Ptc|Psl|PtdoB"
orientacoes$V4[orientacoes$V4=="PsdbPsbPpsPv"] <- "Psdb|Psb|Pps|Pv"
orientacoes$V4[orientacoes$V4=="PtPsdPrPdtProsPc"] <- "Psdb|Psb|Pps|Pv"
orientacoes$V4[orientacoes$V4=="Repr.PSL"] <- "PSL"
orientacoes$V4[orientacoes$V4=="Repr.PTC"] <- "PTC"
orientacoes$V4[orientacoes$V4=="Repr.PTdoB"] <- "PTdoB"
orientacoes$V4[orientacoes$V4=="Solidaried"] <- "SD"
orientacoes$V4[orientacoes$V4=="GOV."] <- "Gov"
orientacoes$V4[orientacoes$V4=="Repr.PSOL"] <- "psol"
orientacoes$V4[orientacoes$V4=="PtPsdPrPdtProsPcdob"] <- "Pt|Psd|Pr|Pdt|Pros|Pcdob"
orientacoes$V4[orientacoes$V4=="PsdbPsbPps"] <- "Psdb|Psb|Pps"
# Altera as entradas pra facilitar trabalho
# Estamos separando partidos com '|', para poder separa-los em colunas
# posteriormente
orientacoes$V4 <- tolower(orientacoes$V4)
# transforma partidos tudo para letras minusculas
orientacoes <- orientacoes %>%
transform(V4 = strsplit(V4, "\\|")) %>%
unnest(V4)
# Separa as variaveis
colnames(orientacoes) <- c("ID_VOTACAO", "DATA", "HORA", "PARTIDO", "ORIENTACAO")
# Altera nomes das colunas de "V4" para nomes pertinentes
orientacoes <- orientacoes[!duplicated(orientacoes),]
# Remove valores duplicados
# Obter apenas a orientacao do governo. Para isso, copiamos o df:
orientacoes <- mutate(orientacoes, ORIENTACAO=ifelse(ORIENTACAO=="Obstrução", "Não", ORIENTACAO))
orientacoes <- spread(orientacoes, PARTIDO, ORIENTACAO)
#  orientacoes <- select(orientacoes, ID_VOTACAO, pt, pmdb, psd, pcdob, pdt, prb, pr , pros)
votos <- read.csv("votos.csv", , stringsAsFactors=FALSE, sep=';')
proposicoes <- read.csv("proposicoes.csv", stringsAsFactors=FALSE, sep=';')
conta_sim <- function(x) {
n_sim <- try(table(x)[["SIM"]], TRUE)
return(n_sim)
}
votos <- votos %>%
filter((VOTO=="SIM" | VOTO=="NAO")) %>%
mutate(votos_sim=ifelse(VOTO=="SIM", 1, 0)) %>%
group_by(ID_VOTACAO) %>%
summarise(contagem=n(), votos_sim=sum(votos_sim))
votos <- inner_join(votos, proposicoes)
library(randomForest)
votos <- inner_join(votos,orientacoes, by="ID_VOTACAO")
votos <- select(votos, ID_VOTACAO, contagem, dem, TIPO, gov, minoria, sd,starts_with("p"), resultado=votos_sim)
nome_colunas <- colnames(votos)[2:length(colnames(votos))]
for (i in nome_colunas) {
print(i)
print(sum(is.na(votos[[i]])))
}
votos <- select(votos, -ptc, -ptdob, -pros, -sd)
for (i in colnames(votos)) {
if (i != "resultado" & i !="contagem") {
votos[[i]] <- as.factor(votos[[i]])
}
}
modelo <- randomForest(resultado ~ gov + minoria + pt + pmdb
+ psdb + psd + TIPO + prp + pr + pps,
data=votos, ntree=500)
table(votos$gov)
table(votos$pt)
vari <- c("Sim", "Não", "Liberado")
varo <- c("Sim", "Não")
vara <- c("MPV", "PDC", "PEC", "PL", "PLP", "REQ")
previsor <- expand.grid(varo, vari, vari,
vari, vari,  varo, vara, vari, vari, vari)
colnames(previsor) <- c("gov", "minoria",  "pmdb",
"psd", "psdb",  "pt", "TIPO", "pp", "pr", "prp")
previsor <- as.data.frame(previsor, stringsAsFactors=FALSE)
previsor$resultado <- predict(modelo,previsor)
write.csv(previsor, "previsto2.csv", row.names=FALSE)
vari <- c("Sim", "Não", "Liberado")
varo <- c("Sim", "Não")
vara <- c("MPV", "PDC", "PEC", "PL", "PLP", "REQ")
previsor <- expand.grid(varo, vari, vari,
vari, vari,  varo, vara, vari, vari, vari)
colnames(previsor) <- c("gov", "minoria",  "pmdb",
"psd", "psdb",  "pt", "TIPO", "pps", "pr", "prp")
previsor <- as.data.frame(previsor, stringsAsFactors=FALSE)
previsor$resultado <- predict(modelo,previsor)
write.csv(previsor, "previsto2.csv", row.names=FALSE)
table(votos$pps)
table(votos$pr)
table(votos$prp)
vari <- c("Sim", "Não", "Liberado")
varo <- c("Sim", "Não")
vara <- c("MPV", "PDC", "PEC", "PL", "PLP", "REQ")
previsor <- expand.grid(varo, vari, vari,
vari, vari,  varo, vara, vari, vari, varo)
colnames(previsor) <- c("gov", "minoria",  "pmdb",
"psd", "psdb",  "pt", "TIPO", "pps", "pr", "prp")
previsor <- as.data.frame(previsor, stringsAsFactors=FALSE)
previsor$resultado <- predict(modelo,previsor)
write.csv(previsor, "previsto2.csv", row.names=FALSE)
vari <- c("Sim", "Não", "Liberado")
varo <- c("Sim", "Não")
vara <- c("MPV", "PDC", "PEC", "PL", "PLP", "REQ")
previsor <- expand.grid(varo, vari, vari,
vari, vari,  varo, vara, varo, vari, vari)
colnames(previsor) <- c("gov", "minoria",  "pmdb",
"psd", "psdb",  "pt", "TIPO", "pps", "pr", "prp")
previsor <- as.data.frame(previsor, stringsAsFactors=FALSE)
previsor$resultado <- predict(modelo,previsor)
write.csv(previsor, "previsto2.csv", row.names=FALSE)
getwd()
setwd('/var/www//html/twitter-protesto/')
library(RMongo)
db <- mongoDbConnect('twitter', host='192.168.0.10')
dbGetQuery(db, "dilma_16_ago", )
result = dbGetQuery(db, "dilma_16_ago", "{}", 0, 1000)
str(result)
as.POSIXlt(1268736919, origin="1970-01-01", tz="America/New_York")
as.POSIXlt(1439239496130, origin="1970-01-01", tz="America/New_York")
as.POSIXlt(1439239496130, origin="1970-01-01", tz="America/New_York")
as.POSIXct(1439239496130, origin="1970-01-01", tz="America/New_York")
as.POSIXct(1439239684918, origin="1970-01-01", tz="America/New_York")
?as.POSIXct
as.POSIXct(1403907978000, origin="1970-01-01", tz="America/New_York")
as.POSIXct(1403907978001, origin="1970-01-01", tz="America/New_York")
as.POSIXct(1403907978000, origin="1970-01-01", tz="America/New_York")
as.POSIXct((1403907978000)/1000, origin="1970-01-01", tz="America/New_York")
as.POSIXct((1403907978001)/1000, origin="1970-01-01", tz="America/New_York")
as.POSIXct((1403907979001)/1000, origin="1970-01-01", tz="America/New_York")
Sys.timezone()
d_time <- function(x) {
return(as.POSIXlt((x/1000), origin="1970-01-01", tz="America/Sao_Paulo"))
}
d_time(1403907978000)
d_time <- function(x) {
return(as.POSIXct((x/1000), origin="1970-01-01", tz="America/Sao_Paulo"))
}
d_time(1403907978000)
v <- d_time(1403907978000)
v
print(v)
summary()v
summary(v)
str(v)
format(.leap.seconds)
print(v)
cat(v)
ju <- cat(v)
jy
ju
ju <- print(as.vector(v))
ju
results
result
result[1]
result[1,]
d_time(1439239496130)
as.POSIXct("2015-08-10 17:44:56 BRT")
teste <- as.POSIXct("2015-08-10 17:44:56 BRT")
teste
r_time(teste)
r_time <- function(x) {
return(as.vector(x))
}
r_time(teste)
20:00:00 + 1
as.POSIXct(20:00:00) + 1
teste
teste$hour + 1
teste$hour
teste$year
year(teste)
?DateTimeClasses
d_time <- function(x) {
return(as.POSIXlt((x/1000), origin="1970-01-01", tz="America/Sao_Paulo"))
}
first_time <- as.POSIXlt("2015-08-10 17:44:56 BRT", origin="1970-01-01", tz="America/Sao_Paulo")
first_time
as.vector(first_time)
str(first_time)
first_time$sec
first_time$hour
first_time$hour + 1
as.POSIXct(first_time)
as.vector(as.POSIXct(first_time))
first_time <- as.POSIXlt("2015-08-10 18:00:00 BRT", origin="1970-01-01", tz="America/Sao_Paulo")
tempo <- first_time
first_time
first_time$year + 1
first_time$year
first_time$hour
first_time$hour + 1
first_time
first_time + as.POSIXlt("01:00:00 BRT")
first_time + as.POSIXlt("01:00:00")
first_time + as.POSIXct("01:00:00")
first_time + 3600
for (i in 2:50) {
tempo[i] <- tempo[i-1] + 3600
}
tempo
?sapply
grid_tempo <- sapply(tempo, r_time)
grid_tempo
r_time(tempo[1])
first_time <- as.POSIXct("2015-08-10 18:00:00 BRT", origin="1970-01-01", tz="America/Sao_Paulo")
tempo <- first_time
for (i in 2:50) {
tempo[i] <- tempo[i-1] + 3600
}
r_time <- function(x) {
return(as.vector(x))
}
grid_tempo <- sapply(tempo, r_time)
grid_tempo
tempo
grid_tempo <- data.frame(initial_time=sapply(tempo, r_time))
?leap
?lah
?lag
lag(grid_tempo)
lag(grid_tempo$initial_time)
lag(grid_tempo$initial_time, k=-1)
lag(grid_tempo$initial_time, k=2)
lag(grid_tempo$initial_time, k=3)
grid_tempo$initial_time
grid_tempo$final_time <- lead(grid$tempo$initial_time)
lead(grid$tempo$initial_time)
grid_tempo$final_time <- lead(grid_tempo$initial_time)
head(grid_tempó)
head(grid_tempo)
exemplo_grid <- grid_tempo[1,]
exemplo_grid
result[1,]
result$timestamp_ms
exemplo_grid$final_value
exemplo_grid
exemplo_grid$initial_time
teste <- result = dbGetQuery(db, 'dilma_16_ago','{$and: [ {"timestamp_ms" : { $lte: exemplo_grid$final_time}},
{"timestamp_ms" : { $gte: exemplo_grid$initial_time}} ]}', 0, 100)
`%p%` <- function(e1, e2) {
return(paste0(e1, e2))
}
"dunha" %p% "moacir"
busca <- '{$and: [ {"timestamp_ms" : { $lte: ' %p% exemplo_grid$final_time %p% '}},
{"timestamp_ms" : { $gte: ' %p% exemplo_grid$initial_time %p% ''}} ]}'
busca <- '{$and: [ {"timestamp_ms" : { $lte: ' %p% exemplo_grid$final_time
busca <- '{$and: [ {"timestamp_ms" : { $lte: ' %p% exemplo_grid$final_time %p% '}},
{"timestamp_ms" : { $gte: ' %p% exemplo_grid$initial_time %p% '}} ]}'
buscqa
busca
teste <- dbGetQuery(db, 'dilma_16_ago', busca, 0, 100)
teste
grid_tempo$initial_value <- grid$tempo_initial_value * 1000
grid_tempo$initial_value <- grid_tempo_initial_value * 1000
grid_tempo$initial_value <- grid_tempo$initial_value * 1000
grid_tempo <- data.frame(initial_time=sapply(tempo, r_time))
str(grid_tempo)
grid_tempo$initial_time[1]
grid_tempo$initial_time[1]*1000
grid_tempo$initial_time*1000
grid_tempo$initial_time <- grid_tempo$initial_time*1000
grid_tempo$final_time <- lead(grid_tempo$initial_time)
exemplo_grid <- grid_tempo[1,]
busca <- '{$and: [ {"timestamp_ms" : { $lte: ' %p% exemplo_grid$final_time %p% '}},
{"timestamp_ms" : { $gte: ' %p% exemplo_grid$initial_time %p% '}} ]}'
teste <- dbGetQuery(db, 'dilma_16_ago', busca, 0, 100)
teste
exemplo_grid
